---
description: ENFORCE Drizzle ORM schema standards when creating or modifying database schemas
globs: ["packages/**/*.db.ts", "apps/**/db/**/*.ts", "apps/**/schema/**/*.ts"]
alwaysApply: false
---

# Drizzle Standards

<version>1.0.0</version>

## Related Standards

- **Authentication**: See `better-auth-standards` for auth-specific schema patterns and session management
- **Validation**: See `zod-validation` for detailed schema validation patterns
- **API Integration**: See `hono-standards` for API endpoint integration with Drizzle

## Context

- Defines standards for Drizzle ORM schema creation
- Ensures consistent database modeling
- Maintains type safety with TypeScript
- Integrates with migrations
- Supports relations and constraints
- Enables efficient querying patterns

## Requirements

### Schema Organization

- [ ] Use domain-driven schema files
- [ ] Create reusable column definitions
- [ ] Implement proper indexes
- [ ] Version migrations properly
- [ ] Document relations
- [ ] Include type exports
- [ ] Define constraints

### Integration Points

- [ ] Migration management
- [ ] Type generation
- [ ] Query optimization
- [ ] Relation handling
- [ ] Index management
- [ ] Constraint validation

## Standards

### Base Schema Patterns

<example>
    // typescript
    import { pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core'
    import { relations, sql } from 'drizzle-orm'
    import { createInsertSchema, createSelectSchema } from 'drizzle-zod'

    // Define base columns for all tables
    const baseColumns = {
      id: uuid('id').primaryKey().defaultRandom(),
      createdAt: timestamp('created_at').defaultNow().notNull(),
      updatedAt: timestamp('updated_at').defaultNow().notNull()
    }

    // Create table with base columns
    export const users = pgTable('users', {
      ...baseColumns,
      email: text('email').notNull().unique(),
      name: text('name').notNull(),
      role: text('role', { enum: ['user', 'admin'] }).default('user').notNull()
    })

    // Define relations
    export const usersRelations = relations(users, ({ many }) => ({
      posts: many(posts)
    }))

    // Export Zod schemas for validation
    export const insertUserSchema = createInsertSchema(users)
    export const selectUserSchema = createSelectSchema(users)

    // Export types
    export type User = typeof users.$inferSelect
    export type NewUser = typeof users.$inferInsert
</example>

### Relations and Constraints

<example>
    // typescript
    import { integer, pgTable, text, uuid } from 'drizzle-orm/pg-core'
    import { relations } from 'drizzle-orm'

    export const posts = pgTable('posts', {
      ...baseColumns,
      title: text('title').notNull(),
      content: text('content').notNull(),
      authorId: uuid('author_id')
        .notNull()
        .references(() => users.id, {
          onDelete: 'cascade'
        })
    }, (table) => ({
      // Define indexes
      authorIdx: index('author_idx').on(table.authorId),
      titleIdx: index('title_idx').on(table.title),
      // Composite indexes
      authorTitleIdx: index('author_title_idx').on(
        table.authorId,
        table.title
      )
    }))

    // Define relations
    export const postsRelations = relations(posts, ({ one }) => ({
      author: one(users, {
        fields: [posts.authorId],
        references: [users.id]
      })
    }))

    // Many-to-many relation
    export const postTags = pgTable('post_tags', {
      postId: uuid('post_id')
        .notNull()
        .references(() => posts.id, { onDelete: 'cascade' }),
      tagId: uuid('tag_id')
        .notNull()
        .references(() => tags.id, { onDelete: 'cascade' }),
    }, (table) => ({
      pk: primaryKey(table.postId, table.tagId)
    }))
</example>

### Query Patterns

<example>
    // typescript
    import { and, desc, eq, sql } from 'drizzle-orm'
    import { db } from '../db'

    // Use prepared statements
    const getUserPosts = db.query.users.findFirst({
      where: (users, { eq }) => eq(users.id, sql.placeholder('id')),
      with: {
        posts: {
          orderBy: (posts, { desc }) => [desc(posts.createdAt)],
          limit: 10
        }
      }
    }).prepare('get_user_posts')

    // Efficient joins
    const getPostWithAuthor = db.select({
      post: posts,
      author: {
        id: users.id,
        name: users.name
      }
    })
    .from(posts)
    .leftJoin(users, eq(posts.authorId, users.id))
    .where(eq(posts.id, postId))

    // Transactions
    await db.transaction(async (tx) => {
      const [user] = await tx
        .insert(users)
        .values({
          email,
          name
        })
        .returning()

      await tx
        .insert(posts)
        .values({
          authorId: user.id,
          title,
          content
        })
    })
</example>

### Migration Patterns

<example>
    // typescript
    import { migrate } from 'drizzle-orm/node-postgres/migrator'
    import { drizzle } from 'drizzle-orm/node-postgres'

    // Migration configuration
    export async function runMigrations(pool) {
      const db = drizzle(pool)

      console.log('Running migrations...')

      await migrate(db, {
        migrationsFolder: './drizzle/migrations',
        migrationsTable: 'migrations'
      })

      console.log('Migrations complete')
    }

    // Migration file: 0000_initial.ts
    import { pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core'

    export const users = pgTable('users', {
      id: serial('id').primaryKey(),
      name: text('name').notNull(),
      createdAt: timestamp('created_at').defaultNow()
    })
</example>

<example type="invalid">
    // typescript
    // Don't use raw SQL for simple queries
    const users = await db.execute(
      sql`SELECT * FROM users`  // Wrong: Use Drizzle query builder
    )

    // Don't skip relations
    const posts = pgTable('posts', {
      userId: uuid('user_id')  // Wrong: Missing relation definition
    })

    // Don't use non-standard naming
    const userPosts = pgTable('UserPosts', {  // Wrong: Use snake_case
      ID: uuid('ID').primaryKey()  // Wrong: Use lowercase
    })

    // Don't skip indexes for foreign keys
    const comments = pgTable('comments', {
      postId: uuid('post_id').references(() => posts.id)
      // Wrong: Missing index on foreign key
    })

    // Don't use string enums without validation
    const status = text('status')  // Wrong: Use enum or check constraint
</example>

### Performance Optimization

<example>
    // typescript
    import { pgTable, index, varchar } from 'drizzle-orm/pg-core'

    // Efficient indexing
    export const products = pgTable('products', {
      id: uuid('id').primaryKey().defaultRandom(),
      name: varchar('name', { length: 255 }).notNull(),
      sku: varchar('sku', { length: 50 }).notNull().unique(),
      description: text('description')
    }, (table) => ({
      // Partial index
      nameIdx: index('name_idx')
        .on(table.name)
        .using('gin')
        .concurrently(),

      // Composite index with included columns
      skuNameIdx: index('sku_name_idx')
        .on(table.sku, table.name)
        .include(table.description)
    }))

    // Efficient querying
    const getProducts = db
      .select()
      .from(products)
      .where(sql`to_tsvector('english', ${products.name}) @@ to_tsquery('english', ${searchTerm})`)
      .limit(20)
      .prepare('search_products')
</example>

### Query Optimization Best Practices

<example>
    // typescript
    import { and, eq, sql, desc, inArray } from 'drizzle-orm'
    import { db } from '../db'

    // Use select specific columns
    const getPostSummaries = db
      .select({
        id: posts.id,
        title: posts.title,
        authorName: users.name
      })
      .from(posts)
      .leftJoin(users, eq(posts.authorId, users.id))
      .limit(20)
      .prepare('get_post_summaries')

    // Batch operations
    const insertPosts = db
      .insert(posts)
      .values(newPosts)
      .returning()
      .prepare('batch_insert_posts')

    // Efficient filtering with indexes
    const searchPosts = db
      .select()
      .from(posts)
      .where(
        and(
          eq(posts.published, true),
          inArray(posts.categoryId, categories)
        )
      )
      .orderBy(desc(posts.createdAt))
      .limit(10)
      .prepare('search_posts')

    // Use transactions for consistency
    await db.transaction(async (tx) => {
      const [post] = await tx
        .insert(posts)
        .values(newPost)
        .returning()

      await tx
        .insert(postTags)
        .values(
          tags.map(tagId => ({
            postId: post.id,
            tagId
          }))
        )
    })
</example>

<example type="invalid">
    // typescript
    // Don't select all columns unnecessarily
    const posts = await db
      .select()  // Wrong: Select specific columns
      .from(posts)

    // Don't use multiple queries when one would do
    const post = await db
      .select()
      .from(posts)
      .where(eq(posts.id, postId))
      .limit(1)
    const author = await db  // Wrong: Use join instead
      .select()
      .from(users)
      .where(eq(users.id, post.authorId))

    // Don't skip prepared statements for repeated queries
    app.get('/posts/:id', async (c) => {
      // Wrong: Should use prepared statement
      const post = await db
        .select()
        .from(posts)
        .where(eq(posts.id, c.req.param('id')))
    })

    // Don't ignore indexing for frequently filtered columns
    const searchPosts = db
      .select()
      .from(posts)
      .where(sql`LOWER(title) LIKE ${pattern}`)  // Wrong: Use proper indexing
</example>

### Schema Validation with Drizzle-Zod

<example>
    // typescript
    import { pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core'
    import { createInsertSchema, createSelectSchema } from 'drizzle-zod'
    import { z } from 'zod'

    // Define custom Zod types for common patterns
    const emailSchema = z.string().email()
    const passwordSchema = z.string().min(8)
    const timestampSchema = z.date()

    // Create table with validation
    export const users = pgTable('users', {
      id: uuid('id').primaryKey().defaultRandom(),
      email: text('email').notNull().unique(),
      password: text('password').notNull(),
      role: text('role', { enum: ['user', 'admin'] }).default('user').notNull(),
      createdAt: timestamp('created_at').defaultNow().notNull()
    })

    // Generate base schemas
    const selectUserSchema = createSelectSchema(users)
    const insertUserSchema = createInsertSchema(users)

    // Add custom validation with refinements
    const validateUserInsert = insertUserSchema.extend({
      email: emailSchema,
      password: passwordSchema,
      role: z.enum(['user', 'admin'])
    })

    // Create update schemas by making insert schema partial
    const validateUserUpdate = validateUserInsert.partial().extend({
      // Prevent updating certain fields
      id: z.never().optional(),
      createdAt: z.never().optional()
    })

    // For specific update operations, pick only allowed fields
    const validateUserProfileUpdate = validateUserUpdate.pick({
      name: true,
      email: true
    })

    // Type inference
    type User = z.infer<typeof selectUserSchema>
    type NewUser = z.infer<typeof validateUserInsert>
    type UpdateUser = z.infer<typeof validateUserUpdate>
    type ProfileUpdate = z.infer<typeof validateUserProfileUpdate>

    // Usage in API routes
    app.post('/users', async (c) => {
      const data = await c.req.json()
      const validated = validateUserInsert.parse(data)
      const [user] = await db.insert(users).values(validated).returning()
      return c.json(selectUserSchema.parse(user))
    })

    // PATCH endpoint for partial updates
    app.patch('/users/:id', async (c) => {
      const id = c.req.param('id')
      const data = await c.req.json()

      // Validate partial update data
      const validated = validateUserUpdate.parse(data)

      // Only update if there are changes
      if (Object.keys(validated).length === 0) {
        throw new Error('No valid fields to update')
      }

      const [updated] = await db
        .update(users)
        .set({
          ...validated,
          updatedAt: new Date()
        })
        .where(eq(users.id, id))
        .returning()

      return c.json(selectUserSchema.parse(updated))
    })

    // PATCH endpoint for profile updates (limited fields)
    app.patch('/users/:id/profile', async (c) => {
      const id = c.req.param('id')
      const data = await c.req.json()

      // Validate only allowed profile fields
      const validated = validateUserProfileUpdate.parse(data)

      const [updated] = await db
        .update(users)
        .set({
          ...validated,
          updatedAt: new Date()
        })
        .where(eq(users.id, id))
        .returning()

      return c.json(selectUserSchema.parse(updated))
    })
</example>

<example type="invalid">
    // typescript
    // Don't use non-existent functions
    import { createUpdateSchema } from 'drizzle-zod'  // Wrong: This doesn't exist

    // Don't reuse insert schema directly for updates
    const updateSchema = insertUserSchema  // Wrong: Should use .partial()

    // Don't skip validation in partial updates
    app.patch('/users/:id', async (c) => {
      const data = await c.req.json()
      await db.update(users).set(data)  // Wrong: Missing validation
    })

    // Don't mix validation libraries
    import { IsEmail } from 'class-validator'  // Wrong: Stick to Zod
    class UserDto {
      @IsEmail()
      email: string
    }

    // Don't allow updating protected fields
    const updateSchema = insertUserSchema.partial()  // Wrong: Missing protection for id/createdAt

    // Don't skip schema validation for responses
    return c.json(user)  // Wrong: Missing selectUserSchema.parse()
</example>

### Configuration and Setup

<example>
    // typescript
    // drizzle.config.ts
    import type { Config } from 'drizzle-kit'

    export default {
      schema: './src/db/schema.ts',
      out: './drizzle',
      driver: 'pg',
      dbCredentials: {
        connectionString: process.env.DATABASE_URL!
      },
      verbose: true,
      // Use consistent naming for migrations
      fileName: (timestamp) => `${timestamp}_schema_update`
    } satisfies Config

    // db/index.ts
    import { drizzle } from 'drizzle-orm/node-postgres'
    import { Pool } from 'pg'

    const pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000
    })

    export const db = drizzle(pool, {
      logger: process.env.NODE_ENV === 'development'
    })

    // Cleanup on shutdown
    ['SIGINT', 'SIGTERM'].forEach((signal) => {
      process.on(signal, () => {
        pool.end()
        process.exit(0)
      })
    })
</example>

### Migration Management

<example>
    // typescript
    // drizzle.config.ts
    import { defineConfig } from 'drizzle-kit'

    export default defineConfig({
      schema: './src/schema.ts',
      out: './drizzle',
      driver: 'pg', // 'mysql2' | 'better-sqlite3' | 'libsql' | 'pg'
      dbCredentials: {
        connectionString: process.env.DATABASE_URL!
      },
      // Specify migration options
      migrations: {
        prefix: 'timestamp', // or 'sequential'
        table: '__drizzle_migrations__',
        schema: 'public'
      },
      verbose: true,
      strict: true
    })

    // package.json scripts
    {
      "scripts": {
        "generate": "drizzle-kit generate:pg", // Generate migrations
        "migrate": "drizzle-kit migrate",      // Apply migrations
        "drop": "drizzle-kit drop",           // Drop all tables
        "check": "drizzle-kit check",         // Check for migration conflicts
        "up": "drizzle-kit up",               // Upgrade migration snapshots
        "studio": "drizzle-kit studio"        // Launch Drizzle Studio
      }
    }

    // Example migration workflow
    // 1. Make schema changes in your TypeScript files
    // 2. Generate migration: pnpm generate
    // 3. Review generated SQL in /drizzle folder
    // 4. Apply migration: pnpm migrate
    // 5. Verify changes: pnpm studio
</example>

<example type="invalid">
    // typescript
    // Don't use manual migrations
    import { migrate } from 'drizzle-orm/node-postgres/migrator'
    await migrate(db, { /* ... */ })  // Wrong: Use drizzle-kit instead

    // Don't mix migration tools
    import { Umzug } from 'umzug'     // Wrong: Stick to drizzle-kit

    // Don't skip migration configuration
    export default defineConfig({
      schema: './src/schema.ts'       // Wrong: Missing migration options
    })

    // Don't use raw SQL for migrations
    db.execute(sql`CREATE TABLE ...`) // Wrong: Use drizzle-kit generate
</example>

<critical>
- Use drizzle-zod for schema validation
- Generate types from schema definitions
- Manage migrations through Drizzle
- Use proper connection pooling
- Implement proper shutdown handling
- Follow consistent naming conventions
- Use proper type generation
- Validate all inputs with Zod
- Use prepared statements
- Implement proper error handling
- Use proper indexing strategies
- Follow database best practices
- Generate types from schema
- Use proper migration patterns
- Keep schema and types in sync
</critical>
